<!doctype html public "-//w3c//dtd html 4.0 transitional//en"><html><head>   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">   <meta name="Generator" content="Microsoft Word 97/98">   <meta name="GENERATOR" content="Mozilla/4.75 (Macintosh; U; PPC) [Netscape]">   <title>Introduction to Jacaranda</title></head><body text="#000000" bgcolor="#FFFFFF" link="#990000" vlink="#333399" alink="#333399"><h1><font size=+3><font color="#78146E">Introduction to </font><font color="#C520F8">J</font><font color="#F82AE3">acaranda</font></font></h1><hr WIDTH="100%"><div align=right><a href="../../index.html">To Jacaranda Home</a></div><h2>Contents</h2><ol><li><a href="#finite-state-automata">Finite-State Automata</a></li><li><a href="#finite-state-transducers">Finite-State Transducers</a></li><li><a href="#documents">Documents</a></li><li><a href="#framework-name">Framework Name</a></li></ol><p><br>Aim of this Java framework realization is to provide an easy andcustomizable design for the implementation of different finite-state machines(FSM).<br>The added value in respect to other implementations is the frameworkcharacter of the system, which offers different flexible and customizableparts (hot spots) through which the user not only can change, as usual,the content of the finite-state machine updating the input document withdifferent states and arcs relations, but also customize it in differentways, including type of arcs, kind of output, way of traversing, etc.,creating its own instance of the desired FSM.<br>I begin this introduction briefly explaining some concepts on finite-statemachines and, above all, introducing some terms, used all over the documentation.<h2><a NAME="finite-state-automata"></a>1. Finite-State Automata</h2>A deterministic finite automaton is a mathematical model of a machine thataccepts a particular set of words over some alphabet E.<br>An informal abstraction of the concept can be shown visualizing theautomaton through a black box representing the finite-state control whichreads an input tape. When the read head reaches the end of the input word,the black box informs whether the word has been accepted. This mechanismis also called finite-state acceptor.<blockquote><img SRC="Image1.gif" LOWSRC="Image1.gif" BORDER=0 height=150 width=252></blockquote>Although finite automata are usually thought of as processing strings ofletters over some alphabet, the input can conceptually be elements fromany finite set.<br>In the Jacaranda object-oriented framework implementation the finiteset can be built with any kind of object.<h3>Definition</h3>A deterministic finite-state automaton (DFA) is a quintuple &lt;E,S,s0,d,F>where:<br>&nbsp;<ul><li>E is the input alphabet (a final non empty set of symbols).</li><li><i>S</i> is a finite non empty set of states.</li><li>s0 is the initial state, element of <i>S</i>.</li><li><i>d</i> is the state transition function. d: <i>S</i> x E -> <i>S</i>.</li><li>F is the set of final states, a subset of <i>S</i>.</li></ul><p><br>The input alphabet, E, for any deterministic finite automaton A,is the set of symbols that can appear on the input tape. Each successivesymbol in a word will cause a transition from the present state to anotherstate. The transition is described by the state transition function. Fordeterministic finite-state automata there is exactly one state transitionfor each combination of a symbol a and a state s.<br>To produce a formal description of a DFA it is necessary to enumerateeach part of the quintuple that comprises it. The state transition diagramis used to display the transitions of the <i>d</i> function and at thesame time to illustrate the other four parts of the quintuple.<h3>Example</h3>Let describe a simple DFA with an alphabet of two symbols (1 and 0), whichaccepts all kinds of words where the symbols 1 appears an odd number oftimes.<br>A = &lt;E,S,s0,d,F><br> <br>where<ul><li>E = {0,1}</li><li>S = {q0,q1}</li><li>s0 = q0</li><li>F = {q1}</li></ul>and <i>d</i> is represented by the following transition table:<br><img SRC="Image2.gif" BORDER=0 height=79 width=138><br>&nbsp;<p>And here is the state transition diagram:<blockquote><img SRC="Image3.gif" BORDER=0 height=132 width=194></blockquote><br>&nbsp;<h3>Non Deterministic Finite Automata</h3>A non deterministic finite automaton (NDFA) is a generalization of thedeterministic machines. Important for the recognition ability is that theclass of languages recognized by NDFA is exactly the same as the classof languages recognized by DFA, i.e. their recognition powers are equivalent.<br>The Jacaranda framework allows the full customization of the traversalalgorithm responsible for the recognition of input words. As "out of thebox" implemented variants the frameworks offers the deterministic traversal,as well as the non deterministic one.<h2><a NAME="finite-state-transducers"></a>2. Finite-State Transducers</h2>The finite-state automata are useful when the task is to reliably recognizea sequence, delivery "yes" or "no" as only result. They do not produceoutput.<br>Finite-state machines able to accepts input sequences and translatethem into output sequences are called sequential machines or transducers.Those machines have transitions from one state to the other which generatean output symbol while accepting an input one.<br>The black box representation used for DFA can also be proposed fortransducers, adding an output tape.<blockquote><img SRC="Image4.gif" BORDER=0 height=161 width=255></blockquote><p><br>Application of these machines can be elevators, traffic lights andother devices that monitor and react to limited stimuli.<br>One important application is in the field of computational linguistics:word form analysis and word form generation has proved to be best realized,for performance and memory need, with finite-state transducers.<h3>Definition</h3>A finite-state transducer (FST) is a sextuple &lt;E,I,S,s0,d,w> where:<br> <ul><li>E is the input alphabet.</li><li>I is the output alphabet.</li><li>S is the set of states, a finite non empty set.</li><li>s0 is the initial state.</li><li>d is the state transition function. d: S x E -> S.</li><li>w is the output function. w: S x E -> I.</li></ul><p><br>The formal definition does not specify the set of final states,as the DFA definition does. This is because conceptually the transducerbuilds its output chronologically. In many concrete applications, however,the transducer is used to accumulate a result, that must be confirmed whenthe entire input word has been processed. In such cases we need to specifythe set of final states.<br>Within the Jacaranda framework a transducer is simply seen as an extensionof an automaton. The definition of final states is then included and straightforward.<h3>Example 1</h3>The first example represents a FST which flags occurrences of the patternAAB by printing a 1 on the output tape, only when the substring AAB appearsin the input stream.<br>Notice the use of "/" (slash) to separate input element from outputelement within a single arc.<blockquote><img SRC="Image5.gif" BORDER=0 height=204 width=247></blockquote><h3><a NAME="fst-example-2"></a>Example 2</h3>The second example represents the application of a FST for word forms analysisand generation.<br>&nbsp;<blockquote><img SRC="Image6.gif" BORDER=0 height=120 width=354></blockquote>Notice the use of final states, as confirmation of the output generatedduring the traversal.<br>In this representation not only single characters, but also full symbolsare shown as part of the alphabet.<br>Because the Jacaranda framework uses objects for the single arcs, thiscauses no problem for the application developer. I have however describedin the second cookbook receipt how the framework offers the opportunityto code further information at the end of each recognized sequence. Thisseems an even better solution for this particular case, because the symbols"+Base", "+Past", etc. are not really part of the sequence to analyze orgenerate, rather they are information to deliver at the end of the recognizedsequence, together with its generated output.<br>Another important remark offered by this particular application isthe bi-directional use of the transducer. You can traverse it acceptinginput elements and generating output ones, but you can also traverse itaccepting output elements while generating input ones as result. This iswhy with the same transducer you can analyze the word form "dined", sayingthat it is a past form of "dine", as well as generating "dines" and "dined"as output of the citation form "dine". Both directions can deliver morethan one result. The traversing must therefore consider the non deterministiccharacter of the FSM.<br>This functionality is fully supported by the Jacaranda framework, whichallows the sharing of data for different purposes. In the framework terminologyI call analysis the input/output direction, and generation the output/inputone.<h2><a NAME="documents"></a>3. Documents</h2>The documents used as input of the framework, while allowing customizablekinds of arcs and information for final states, have a formal syntax.<br>Here is its description, using EBNF notation. I will mention it againin the first recipe of the cookbook.<br>&nbsp;<blockquote><pre>document&nbsp;&nbsp;&nbsp;&nbsp; = {state | place-holder}+.</pre><pre>place-holder = index.</pre><pre>state&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = (empty-flag {arc}+) | (info-flag {arc}).</pre><pre>empty-flag&nbsp;&nbsp; = "}".</pre><pre>info-flag&nbsp;&nbsp;&nbsp; = "{" {index}+ "}".</pre><pre>arc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = input-element output-element.</pre><pre>index&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = [-] {digit}+.</pre><pre>input-element -> customized element.</pre><pre>output-element -> customized element.</pre></blockquote><p><br>The following text is an example using characters as input and outputelements:<br>&nbsp;<blockquote>}ccmm<br>}aa<br>}tt<br>}hh<br>}oo<br>}dd<br>{1}s#<br>{2}<br>}ee<br>2</blockquote><p><br>The last element is a place holder for an existing cluster. Thisallows a recursive mechanism and a fairly high compression rate, whichcorresponds to transforming a trie structure into a FSM.<br>A conversion tool (shaken Jacaranda) is needed to produce documentsstarting from a list of words, converted first into a trie and then intoa minimized finite-state structure to be accepted as input by the framework.The tool is not part of this release (different test documents with hundredsof states are delivered with the framework). However, if the structureof the FSM is known, the document can be produced very easily.<br>Let me show how to proceed starting from the following known DFA (onlytransforming the previous used alphabet {0,1} into {a,b}, to be able toread the document more easily at the end of the process, avoiding confusionwith the numbers referring to the states):<blockquote><img SRC="Image7.gif" BORDER=0 height=132 width=194></blockquote>There are three steps to perform:<br> <ul><li>Stretch graphically the FSM (in this case a simple DFA) into a tree, usingthe initial state as root and creating a new child for each arc. Recursivelyrepeat the transformation in a leftmost recursive way for each new generatedchild until each state of the FSM is represented once with all its children.</li></ul><img SRC="Image8.gif" BORDER=0 height=161 width=233><br>&nbsp;<ul><li>Reading the resulting tree in a leftmost recursive way, transform eachrepeated state into a place holder (shown as small square in the followingrepresentation). The resulting tree should appear with all leaves representedas square.</li></ul><img SRC="Image9.gif" BORDER=0 height=162 width=224><br>&nbsp;<ul><li>Copy the elements into a text file always following the leftmost recursivedescent, considering the following:</li><ul><li>If no particular output information needs to be coded into a final state,the latter can be represented with whatever index.</li><li>Each state will use a text line in the file to represent its state informationand its list of outgoing arcs. Each line representing a full state hasan implicit incremental index, starting by 0. This index is used by theplace holders to refer to their original state.</li><li>A place holder is simply an index, referring to its original state.</li></ul></ul>Here is the final document for the considered FSM:<br> <blockquote>}ab<br>0<br>{1}ab<br>1<br>0</blockquote> <p>The formalism is quite simple and could be easily generated by the formaldescription of the FSM. But this is not the peculiarity of the system,which is intended to be used, in a customized way, for large FSMs, withmany thousands of arcs and states, as it is partly shown in the secondreceipt of the delivered cookbook.<h2><a NAME="framework-name"></a>4. Framework Name</h2>The name of the framework, Jacaranda, comes from the name of the impressingtrees that I had the chance to admire every day on the streets of Pretoria,South Africa, during my two months sabbatical period around October 2000at the local university, where I had the opportunity to design and implementthe software.<br>The <a href="../show/show.html">Jacaranda tree</a> is originally nativeof South America, specifically Argentina. The botanical name is Jacarandamimosifolia of the family Bignoniaceae. The tree has adapted well to thewarmer parts of southern Africa and today the main concentrations are inthe region around Pretoria and Johannesburg.<br>Although the Jacaranda tree is not indigenous to South Africa, it hasbecome synonymous with Pretoria so that the city is often referred to asthe Jacaranda city. The large number of Jacarandas along the streets ofPretoria burst into lilac every October, turning the city into a spectaclethat defies description.<br>Jacaranda is also the name of the radio channel (FM 94.2) I was usedto hear during breakfast time in Pretoria (I like such kinds of routines...).<p>The algorithm that I use to prepare the input data for the frameworkstarts from the bottom of a trie structure, i.e. a particular tree structure,removing every redundant node, when possible, and reducing the trie structureinto a finite-state machine structure. I developed the algorithm some yearsago and I called it "shaken trie", because of its characteristic of makingthe leaves of the trie falling down during the process of shaking. Thesimilarity goes well with a <a href="../show/show.html#shaken-jacaranda">shakenJacaranda</a> losing blooms in October.<br>But I am not only romantic. As a matter of fact the framework has beenfully implemented in Java, and the first "J" of Jacaranda is there to confirmit...<br>&nbsp;<p><hr WIDTH="100%"><address><font size=-1>sp 2000</font></address><br>&nbsp;</body></html>